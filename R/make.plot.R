

  #  plot.x_on_axis = function(xlab,ylab,main, res , histogram, data,xs, gr,spotlights,cols,spotlight.labels,focal,moderation,nux,max.unique,fxz.list)

    make.plot     = function(type,xlab,ylab,main, res , histogram, data,xs,zs, gr, spotlights , cols , spotlight.labels ,
                             focal , moderation , max.unique , fxz.list,nux,nuz,xvar,zvar,xlim,ylim,legend.title,
                             x.ticks,y.ticks,jn.x.axis)
          {   
      #res: list with results from either simple.slopes or jn 
      
      #main is entered in call within interprobe(), specifying GAM Simple Slpoes vs GAM jn
      #Dummy to not mess with ylim if set explicitly
        ylim.set.by.user <- !is.null(ylim)
      

    #1 Adjustments based on x or z on the x1 axis
        #1.1 X on AXIS    
            if (jn.x.axis=='focal') {
              if (xlab=='') xlab=xvar
              n.lines  = length(spotlights)
              x1.range = range(data[,xvar])
              x1s=xs
              nux1=nux
              x1.axis='x'
            }
             
        
      #1.2 Z on Axis 
          if (jn.x.axis!='focal') {
            if (xlab=='') xlab=zvar
          
            #Number of lines simple slopes
              if (type=='simple.slopes' & focal!='categorical') n.lines=length(spotlights)
              if (type=='simple.slopes' & focal=='categorical') n.lines=nux
              
            #Number of lines johnson.neyman
              if (type=='jn' & focal=='categorical')   n.lines=nux-1
             
            #for categorical, the dy/dx is the diff in xs so 1 fewer line than x values
              x1.range = range(data[,zvar])
              x1s=zs
              nux1=nuz
              x1.axis='z'
            }
      
      
      
      #1.3 y-axis adjustment if y.ticks with labels provided
          
          if (!is.null(y.ticks) & class(y.ticks)=='data.frame') 
          {
            yline.adj = max(nchar(y.ticks[,2]))/3.25
            m0 = par('mar')
            m1 = m0
            m1[2] = m1[2] + yline.adj
            par(mar=m1)
          }
      
      
    #2 Unlist data.frames
           res.df <- do.call(rbind, res)

    #3 Set ylim
           #Start with range of the CI
              if (is.null(ylim)) ylim = range(res.df[,c('conf.low','conf.high')])            #Default y-range
              
            #Assign to constant to dynamically add 0 below after changing ylim values
              ylim1=ylim[1]
              ylim2=ylim[2]


          #Expand to include 0 if it is marginal effects
              if (type=='jn' & !ylim.set.by.user) {
                
                #If it does not cover 0 currently
                    if (ylim1*ylim2>0)
                    {
                      #If positive, start at 0
                        if (ylim1>0) ylim[1]=0 - .02*diff(ylim)
                      #If negative, end at 0
                        if (ylim1<0) ylim[2]=0 + .02*diff(ylim)
                    }
                
                  }
          #Top space for legend
             if (!ylim.set.by.user) ylim[2]=ylim[2]+.3*diff(ylim)                              
            
         #Bottom space for histogram
            if (histogram==TRUE & !ylim.set.by.user) ylim[1]=ylim[1]- (.15 + n.lines*.07)*diff(ylim)        #add at the bottom for the histogram
          
    #4 Set axes options
            
            #xlim
             if (is.null(xlim)) xlim = x1.range
            
            #draw x and y ticks?
              xaxt = 's'                         #assume we make the default x-axis ticks
              yaxt = 's'                         #assume we make the default y-axis ticks
              
              
              if (!is.null(x.ticks)) xaxt = 'n'  #but not if x.ticks isn't null
              if (!is.null(y.ticks)) yaxt = 'n'  #but not if x.ticks isn't null
          
            #ylab
              ylab.plotted=ylab
              if (!is.null(y.ticks)) ylab.plotted=''
              #by default use the ylab generated by base R, but if user set the ylabels, then eliinate and add it later with mtext
              
    #5 Empty plot
              plot(x1s,res[[1]]$estimate,type='n',xlab=xlab,ylab=ylab.plotted,las=1,ylim=ylim,xlim=xlim,yaxt='n',cex.lab=1.3,font.lab=2,xaxt=xaxt,yaxt=yaxt)
              if (yaxt=='s') axis(2,at=pretty(ylim)[c(-1,-2)],las=1) #y-axis missing lower two ticks to give space to the histogram
            
    #6 Add custom axes ticks if requested
          #x-axis
              if (!is.null(x.ticks)) {
                if (!is.data.frame(x.ticks)) axis(side=1,at=x.ticks)
                if (is.data.frame(x.ticks))  axis(side=1,at=x.ticks[,1], x.ticks[,2])
              }
            
          #y-axis
              if (!is.null(y.ticks)) {
                if (!is.data.frame(y.ticks)) axis(side=2,at=y.ticks,las=1)
                if (is.data.frame(y.ticks))  axis(side=2,at=y.ticks[,1], y.ticks[,2],las=1)
              }
         
    #7 Line at 0 for jn
            if (type=='jn') {
              axis(2,at=0,las=1)
              abline(h=0,lty=2,col='gray77')
              }
    #8 Loop making the 2 or 3 lines
               j=1
               col.seg = cols
               if (focal=='categorical' & type=='jn') col.seg=col.seg[-1]  
               
              #If jning a categorical predictor, drop the first color for that's baseline
               
              for (j in 1:n.lines) {
               #Color of lines
                #Based on frequencies
                  g1=as.numeric(gr[,j])  #this is based on fxz
                
                #If continuous, expand to set of values colored together
                  if (nux1>max.unique)  g = rep(g1 , each=length(x1s)/length(g1))
                  
                #If discrete then just the values once (one line per bin-pair)
                  if (nux1<=max.unique) g = g1
                    
              
                #Lines
                  line.seg(x1s,res[[j]]$estimate,lwd=4*g, col=col.seg[j],g=g) 
              
                  #Changing both width and tly leads to weird looking lines
              
                #Confidence regions
                  polygon(x=c(x1s,rev(x1s)),
                        y=c(res[[j]]$conf.high,
                            rev(res[[j]]$conf.low)),
                            col=adjustcolor(col.seg[j],.1),border = NA)
                  
               #Dots within line if we have not binned data for plotting
                  if (nux1 <= max.unique) points(x1s,res[[j]]$estimate, col=adjustcolor2(col.seg[j],pmax(g,.2)),pch=16,cex=1.5) 

                  
              }#End loop nux
              
              
          #Headers
            yline = max(nchar(as.character(pretty(ylim)))) 
            mtext(side=3,line=1.5,font=2,cex=1.5, main)
     
          #Legend
            if (x1.axis=='x')
              {
              if (is.null(legend.title)) legend.title=zvar

              legend("top",inset=.01,bty='n',lwd=8,col=cols[1:n.lines],
                     title=legend.title,
                     title.font=2,
                     legend=spotlight.labels)
            }
            
            if (x1.axis=='z')
              {
               #Legend title
                  if (is.null(legend.title)) legend.title=paste0("Focal predictor ('",xvar,"')")

                  
                  if (type=='simple.slopes' & focal=='categorical') 
                    {
                    legend("top",inset=.01,bty='n',lwd=5,col=cols[1:n.lines],title=legend.title,title.font=2,legend=xs)
                    }
                  
                  if (type=='simple.slopes' & focal!='categorical') {
                      legend("top",inset=.01,bty='n',lwd=5,col=cols[1:n.lines],title=legend.title, title.font=2,legend=spotlight.labels)
                    }
          
                    
                  
                  
                
                  
                #JN legend
                    if (type=='jn' & focal=='categorical')  {
                        legend("top",inset=.01,bty='n',lwd=5,col=cols[-1],   title=legend.title,title.font=2,legend=paste0(xs[-1]," - ",xs[1]))
                    }
                  
                    if (type=='jn' & focal=='continuous')  {
                        legend("top",inset=.01,bty='n',lwd=5,col=cols[-1],   title=legend.title,title.font=2,legend=spotlight.labels)
                    }
                  
                  
                  
            }
            
            
          #ylab if was not done by default because user entered y.ticks
            if (!is.null(y.ticks)) mtext(side=2,line=par('mar')[2]-1,font=2,cex=1.5,ylab)
            #yline.adj  is adjusted based on the length of the ylab
            
          #Histogram  
              breaks=NULL #these are the x-axis bins for histograms
              if (histogram==TRUE) breaks=draw.histogram(fxz.list, focal, moderation='continuous', x1s, ux1, nux1, cols,ylim,xlim,max.unique)
              #See draw.histogram.R
            
          #Return braks
              return(breaks)
        }           
     
    
    
    
    