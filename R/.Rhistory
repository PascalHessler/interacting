nbins
nbins = n.bin.continuous
fx   = table(data$x,bins)
fx
bins = cut(data$x ,n.bin.continuous)  #n.bin.continuous defaults to 10 bins for continuous data
bins
nbins = n.bin.continuous
zbins <- cut(df$z,
breaks = c(-Inf, quantile(df$z,c(1/3,2/3)), Inf),
labels = c("z1", "z2", "z3"),
include.lowest = TRUE)
zbins <- cut(data$z,
breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),
labels = c("z1", "z2", "z3"),
include.lowest = TRUE)
zbins
fx   = table(binz,zbins)
fx   = table(bins , zbins)
fx
colSums(fx)
bins = cut(data$x ,n.bin.continuous,include.lowest=TRUE,labels=paste('xbin_',1:(n.bin.continuous)))
bins
nbins = n.bin.continuous
bins = cut(data$x ,nbins,include.lowest=TRUE,labels=paste('xbin_',1:(nbins)))  #n.bin.continuous defaults to 10 bins for continuous data
bins
bins = cut(data$x ,nbins,include.lowest=TRUE,labels=paste0('xbin_',1:(nbins)))  #n.bin.continuous defaults to 10 bins for continuous data
zbins <- cut(data$z,
breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),
labels = c("z1", "z2", "z3"),
include.lowest = TRUE)
fx   = table(bins , zbins)
fx
zbins <- cut(data$z,
breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),
labels = paste0("zbin_",1:3),
include.lowest = TRUE)
fx   = table(bins , zbins)
fx
px = prop.table(fx,1)
px
fx   = table(zbins , bins)
fx
px = prop.table(fx,1)
px
compute.slopes.discrete=function(ux, zs, model)
{
simple.slopes = list()
j=1
for (xj in ux)
{
#Make prediction data
ndj = expand.grid(z=zs,x=xj)
#Save marginal effects results
options(warn=-1)
simple.slopes[[j]] = marginaleffects::predictions(model, newdata = ndj,by='z')
options(warn=-0)
#Note: suppress warnings because `marginaleffects` warns about k as a missing variable
j=j+1
} #End loop
return(simple.slopes)
}
compute.slopes.discrete(ux, zs, model)
ux
zs
model
n=200
x=rep(c(1,2,3),n)
z=rnorm(3*n)
y.raw=x*z
e=rnorm(length(y.raw),sd=sd(y.raw))
y=y.raw+e
compute.slopes.continuous=function(spotlights, data, xs)
{
if (is.null(spotlights)) spotlights=quantile(data$z,c(.15,.5,.85),type=3)
simple.slopes = list()
j=1
for (zj in spotlights)
{
#Make prediction data
ndj = expand.grid(z=zj,x=xs)
ndj = add.covariates.at.mean(ndj, data)
#Save marginal effects results
options(warn=-1)
simple.slopes[[j]] = marginaleffects::predictions(model, newdata = ndj)
options(warn=-0)
#Note: suppress warnings because `marginaleffects` warns about k as a missing variable when it is specified
j=j+1
} #End loop
} #End of function
data$x
compute.slopes.continuous(spotlights , data, xs)
compute.slopes.continuous=function(spotlights, data, xs)
{
if (is.null(spotlights)) spotlights=quantile(data$z,c(.15,.5,.85),type=3)
simple.slopes = list()
j=1
for (zj in spotlights)
{
#Make prediction data
ndj = expand.grid(z=zj,x=xs)
ndj = add.covariates.at.mean(ndj, data)
#Save marginal effects results
options(warn=-1)
simple.slopes[[j]] = marginaleffects::predictions(model, newdata = ndj)
options(warn=-0)
#Note: suppress warnings because `marginaleffects` warns about k as a missing variable when it is specified
j=j+1
} #End loop
return(simple.slopes)
} #End of function
s=compute.slopes.continuous(spotlights , data, xs)
s
compute.floodlight.discrete=function(ux, zs, model)
{
floodlight = list()
#Marginal effect for condition 2 - 1, or both 3-1 and 2-1, so we exclude from loop 1, and add to all
j=1
for (xj in ux[-1])
{
#Make prediction data
ndj = expand.grid(z=zs,x=c(as.character(ux[1]),xj))
#Save marginal effects results
options(warn=-1)
floodlight[[j]] = marginaleffects::predictions(model, newdata = ndj,by='z')
floodlight[[j]]$x=xj
options(warn=-0)
#Note: suppress warnings because `marginaleffects` warns about k as a missing variable
#SEE https://github.com/vincentarelbundock/marginaleffects/issues/1031
j=j+1
} #End loop
return(floodlight)
}
nxbins = n.bin.continuous
nxbins
xbins  = cut(data$x ,nbins,include.lowest=TRUE,labels=paste0('xbin_',1:(nbins)))
zbins  = cut(data$z, breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(zbins , bins)
fx
diff(spotlights)
spotlights
names(spotlights)
diff(names(spotlights))
diff(as.numeric(names(spotlights)))
spotlights
mean(z<spotlights)
mean(z<spotlights[1])
mean(z<spotlights[2])
cut1 =( spotlights[1]+spotlights[2])/2)
cut1 =( spotlights[1]+spotlights[2])/2
cut1
cuts=c()
cuts[1] =( spotlights[1]+spotlights[2])/2
cuts[2] =( spotlights[3]+spotlights[2])/2
cuts
quantile(data$z,c(1/3,2/3))
nxbins = n.bin.continuous
#Cut x into nbins
xbins  = cut(data$x ,nxbins,include.lowest=TRUE,labels=paste0('xbin_',1:(nxbins)))
xbins
cuts=c()
cuts[1] =( spotlights[1]+spotlights[2])/2
cuts[2] =( spotlights[3]+spotlights[2])/2
zbins  = cut(data$z, breaks = c(-Inf, cuts, Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(zbins , bins)
fx
make.fbin = function(data  , n.bin.continuous,  moderation  )
{
#------------------------------------------------------------
#CASE 1  x: contintuous, always plot three lines for spotlights of z
if (nux>3) {
#How many bins for x values?
nxbins = n.bin.continuous
#Cut x into nbins
xbins  = cut(data$x ,nxbins,include.lowest=TRUE,labels=paste0('xbin_',1:(nxbins)))
#Cut z into three
cuts=c()
cuts[1] =( spotlights[1]+spotlights[2])/2
cuts[2] =( spotlights[3]+spotlights[2])/2
#Spotlights has to have three values, and it takes the midpoints of those three values to make the three bins
zbins  = cut(data$z, breaks = c(-Inf, cuts, Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
#Compute the cross frequencies
fx   = table(zbins , bins)
return(fx)
}
#------------------------------------------------------------
#CASE 2  x: discrete z: cont
if (nux<3 & moderation=='continuous') {
zbins  = cut(data$z, breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(zbins , ux)
return(fx)
}
#------------------------------------------------------------
#CASE 3  x: discrete z: discrete
if (nux<3 & moderation=='discrete') {
fx   = table(uz , ux)
return(fx)
}
}
x=rnorm(1000)
z=rnorm(1000)
spotlights=quantile(z,c(.15,.5,.85))
xbins  = cut(data$x ,nxbins,include.lowest=TRUE,labels=paste0('xbin_',1:(nxbins)))
xbins
cuts=c()
cuts[1] =( spotlights[1]+spotlights[2])/2
cuts[2] =( spotlights[3]+spotlights[2])/2
zbins  = cut(data$z, breaks = c(-Inf, cuts, Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(zbins , bins)
fx
xbins
nxbins
x=sample(c(0,1),1000)
x=sample(c(0,1),1000,replace = T)
z=rnorm(1000)
zbins  = cut(data$z, breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(zbins , ux)
fx
zbins
ux
ux=unique(x)
fx   = table(zbins , ux)
fx
ux
zbins
table(zbins , ux)
table(zbins , x)
x=sample(c(0,1),1000,replace = T)
z=sample(c(1,2,3,4,5,6,7),replace=T)
fx   = table(z , x)
z=sample(c(1,2,3,4,5,6,7),1000,replace=T)
table(z , x)
table(zbins , x)
make.fxz = function(data  , n.bin.continuous,  moderation  )
{
#------------------------------------------------------------
#CASE 1  x: contintuous, always plot three lines for spotlights of z
if (nux>3) {
#How many bins for x values?
nxbins = n.bin.continuous
#Cut x into nbins
xbins  = cut(data$x ,nxbins,include.lowest=TRUE,labels=paste0('xbin_',1:(nxbins)))
#Cut z into three
cuts=c()
cuts[1] =( spotlights[1]+spotlights[2])/2
cuts[2] =( spotlights[3]+spotlights[2])/2
#Spotlights has to have three values, and it takes the midpoints of those three values to make the three bins
zbins  = cut(data$z, breaks = c(-Inf, cuts, Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
#Compute the cross frequencies
fx   = table(xbins,zbins)
return(fx)
}
#------------------------------------------------------------
#CASE 2  x: discrete z: cont
if (nux<3 & moderation=='continuous') {
zbins  = cut(data$z, breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(x,zbins)
return(fx)
}
#------------------------------------------------------------
#CASE 3  x: discrete z: discrete
if (nux<3 & moderation=='discrete') {
fx   = table(x,z)
return(fx)
}
}
make.fxz = function(data  , n.bin.continuous,  moderation  )
{
#------------------------------------------------------------
#CASE 1  x: contintuous, always plot three lines for spotlights of z
if (nux>3) {
#How many bins for x values?
nxbins = n.bin.continuous
#Cut x into nbins
xbins  = cut(data$x ,nxbins,include.lowest=TRUE,labels=paste0('xbin_',1:(nxbins)))
#Cut z into three
cuts=c()
cuts[1] =( spotlights[1]+spotlights[2])/2
cuts[2] =( spotlights[3]+spotlights[2])/2
#Spotlights has to have three values, and it takes the midpoints of those three values to make the three bins
zbins  = cut(data$z, breaks = c(-Inf, cuts, Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
#Compute the cross frequencies
fx   = table(xbins,zbins)
return(fx)
}
#------------------------------------------------------------
#CASE 2  x: discrete z: cont
if (nux<3 & moderation=='continuous') {
zbins  = cut(data$z, breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(x,zbins)
return(fx)
}
#------------------------------------------------------------
#CASE 3  x: discrete z: discrete
if (nux<3 & moderation=='discrete') {
fx   = table(x,z)
return(fx)
}
}
#SOURCE
rm(list = ls())
pkg_path <- "c:/git/interacting/r"
scripts<-list.files(pkg_path,full.names = TRUE)
for (scriptk in scripts) {
if (!basename(scriptk) %in% c('interprobe.R','interprobe_dev.R')) {
message("next:",basename(scriptk))
source(scriptk)
} }
#SOURCE
rm(list = ls())
pkg_path <- "c:/git/interacting/r"
scripts<-list.files(pkg_path,full.names = TRUE)
for (scriptk in scripts) {
if (!basename(scriptk) %in% c('interprobe.R','interprobe_dev.R')) {
message("next:",basename(scriptk))
source(scriptk)
} }
#SOURCE
rm(list = ls())
pkg_path <- "c:/git/interacting/r"
scripts<-list.files(pkg_path,full.names = TRUE)
for (scriptk in scripts) {
if (!basename(scriptk) %in% c('interprobe.R','interprobe_dev.R','interprobe_dev2.R')) {
message("next:",basename(scriptk))
source(scriptk)
} }
#SOURCE
rm(list = ls())
pkg_path <- "c:/git/interacting/r"
scripts<-list.files(pkg_path,full.names = TRUE)
for (scriptk in scripts) {
if (!basename(scriptk) %in% c('interprobe.R','interprobe_dev.R','interprobe_dev2.R')) {
message("next:",basename(scriptk))
source(scriptk)
} }
data=NULL
model=NULL
k=NULL
zs=NULL
spotlights=NULL
draw=TRUE
histogram=TRUE
nbins=NULL
shade.up.to = 50  #below this sample size we shade to show few observations
xlab='moderator'
cols=c('red4','blue4','green4')
ylab1='Dependent Variable'
ylab2='Marginal Effect'
main1="GAM Simple Slopes"
main2='GAM Floodlight'
force.discrete.freqs=FALSE
n.bin.continuous = 10
max.unique=11
draw.simple.slopes=TRUE
draw.floodlight=TRUE
n=200
x=rep(c(1,2,3),n)
z=rnorm(3*n)
y.raw=x*z
e=rnorm(length(y.raw),sd=sd(y.raw))
y=y.raw+e
#0 If x is specified and it is in a model/data version of interprobe() treat as string
if (!is.null(model) | !is.null(data)) {
x <- deparse(substitute(x))
z <- deparse(substitute(z))
if (!is.null(y)) y <- deparse(substitute(y))
}
#1 Validate input and determine what was provided, vector, model, or data.frame
v = validate.input.combinations(data , model, x, y ,z)
#2 Create data
#Extract if provided
if (v$input.data==FALSE & v$input.xyz==TRUE)  data = data.frame(x=x,z=z,y=y)
if (v$input.model==TRUE)                      data = model$model
#Combine vectors otherwise
if (v$input.data==FALSE & v$input.xyz==TRUE)
{
#Put vectors into dataframe
data=data.frame(x, z, y)
#Rename variables to refer to variable names
x='x'
z='z'
y='y'
}
ux  = sort(unique(data$x))
uz  = sort(unique(data$z))
nux = length(ux)     #nux number of unique x values
nuz = length(uz)     #nuz number of unique z values
nuz
nux
#3.2 Check if only 1 value
if (nux==1) stop("interprobe says: there is only one observed value for the variable 'x'")
if (nuz==1) stop("interprobe says: there is only one observed value for the variable 'z'")
moderation = ifelse(nuz > max.unique, 'continuous', 'discrete')
focal      = ifelse(nux > max.unique, 'continuous', 'discrete')
moderation
focal
if (moderation=='discrete')   zs = uz
if (moderation=='continuous') zs = seq(min(data$z),max(data$z),length.out=100)
moderation
moderation
if (moderation=='discrete')   zs = uz
if (moderation=='continuous') zs = seq(min(data$z),max(data$z),length.out=100)
#set focal predictor values
if (focal=='discrete')   xs = ux
if (focal=='continuous') xs = seq(min(data$x),max(data$x),length.out=100)
if (v$input.model==FALSE) model = estimate.model(nux,data,k)
#6 Compute simple slopes
if (is.null(spotlights)) spotlights=quantile(z,c(.15,.5,.85),type=3)
if (draw.simple.slopes==TRUE) {
if (nux  <4)  simple.slopes = compute.slopes.discrete  (ux, zs, model)
if (nux >=4)  simple.slopes = compute.slopes.continuous(spotlights, data, xs)
}
if (draw.floodlight ==TRUE) {
if (nux  <4)  floodlight = compute.floodlight.discrete  (ux, zs, model)
if (nux >=4)  floodlight = compute.floodlight.continuous(spotlights, data, xs)
}
fxz = make.fxz(data  , n.bin.continuous,  moderation)
fxz
data
n.bin.continuous
moderation
make.fxz(data  , n.bin.continuous,  moderation)
make.fxz = function(data  , n.bin.continuous,  moderation  )
{
#------------------------------------------------------------
#CASE 1  x: contintuous, always plot three lines for spotlights of z
if (nux>3) {
#How many bins for x values?
nxbins = n.bin.continuous
#Cut x into nbins
xbins  = cut(data$x ,nxbins,include.lowest=TRUE,labels=paste0('xbin_',1:(nxbins)))
#Cut z into three
cuts=c()
cuts[1] =( spotlights[1]+spotlights[2])/2
cuts[2] =( spotlights[3]+spotlights[2])/2
#Spotlights has to have three values, and it takes the midpoints of those three values to make the three bins
zbins  = cut(data$z, breaks = c(-Inf, cuts, Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
#Compute the cross frequencies
fx   = table(xbins,zbins)
return(fx)
}
#------------------------------------------------------------
#CASE 2  x: discrete z: cont
if (nux<=3 & moderation=='continuous') {
zbins  = cut(data$z, breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(x,zbins)
return(fx)
}
#------------------------------------------------------------
#CASE 3  x: discrete z: discrete
if (nux<=3 & moderation=='discrete') {
fx   = table(x,z)
return(fx)
}
}
fxz = make.fxz(data  , n.bin.continuous,  moderation)
(nux<=3 & moderation=='continuous')
zbins  = cut(data$z, breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
zbins
x
if (nux<=3 & moderation=='continuous') {
zbins  = cut(data$z, breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(data$x,zbins)
return(fx)
}
make.fxz = function(data  , n.bin.continuous,  moderation  )
{
#------------------------------------------------------------
#CASE 1  x: contintuous, always plot three lines for spotlights of z
if (nux>3) {
#How many bins for x values?
nxbins = n.bin.continuous
#Cut x into nbins
xbins  = cut(data$x ,nxbins,include.lowest=TRUE,labels=paste0('xbin_',1:(nxbins)))
#Cut z into three
cuts=c()
cuts[1] =( spotlights[1]+spotlights[2])/2
cuts[2] =( spotlights[3]+spotlights[2])/2
#Spotlights has to have three values, and it takes the midpoints of those three values to make the three bins
zbins  = cut(data$z, breaks = c(-Inf, cuts, Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
#Compute the cross frequencies
fx   = table(xbins,zbins)
return(fx)
}
#------------------------------------------------------------
#CASE 2  x: discrete z: cont
if (nux<=3 & moderation=='continuous') {
zbins  = cut(data$z, breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(data$x,zbins)
return(fx)
}
#------------------------------------------------------------
#CASE 3  x: discrete z: discrete
if (nux<=3 & moderation=='discrete') {
fx   = table(data$x,data$z)
return(fx)
}
}
fxz = make.fxz(data  , n.bin.continuous,  moderation)
fxz
moderation
zbins  = cut(data$z, breaks = 10,  labels = paste0("zbin_",1:10), include.lowest = TRUE)
zbins  = cut(data$z, breaks = 5,  labels = paste0("zbin_",1:5), include.lowest = TRUE)
zbins
fx   = table(data$x,zbins)
fx
hist(z)
hist(data$z)
zbins  = cut(data$z, breaks = 10,  labels = paste0("zbin_",1:5), include.lowest = TRUE)
zbins  = cut(data$z, breaks = 10,  labels = paste0("zbin_",1:5), include.lowest = TRUE)
zbins  = cut(data$z, breaks = 10,  labels = paste0("zbin_",1:10), include.lowest = TRUE)
fx   = table(data$x,zbins)
fx
