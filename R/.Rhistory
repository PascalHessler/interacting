xlim[1]=xlim[1]-.05*diff(xlim) #add margin to left to put the 'n='
#Empty plot
plot(xs,simple.slopes[[1]]$estimate,type='n',xlab=xlab,ylab=ylab1,las=1,ylim=ylim,xlim=xlim,yaxt='n',cex.lab=1.3)
axis(2,at=pretty(ylim)[c(-1,-2)],las=1) #y-axis missing lower two tikcs to give space to the histogram
#ltys=c(1,2,4)
ltys=c(1,1,1)
n.lines=length(simple.slopes)
j=1
for (j in 1:n.lines) {
#Lines
line.seg(zs,simple.slopes[[j]]$estimate,lwd=4*gr[[j]], col=cols[j],g=gr[[j]],lty=ltys[j])
#Changing both width and tly leads to weird looking lines
#Confidence regions
polygon(x=c(zs,rev(zs)),
y=c(simple.slopes[[j]]$conf.high,
rev(simple.slopes[[j]]$conf.low)),
col=adjustcolor(cols[j],.1),border = NA)
#Dots if we have not binned data
#  if (nuz==nbins) points(zs,simple.slopes[[j]]$estimate, col=adjustcolor2(cols[j],gr[[j]]),pch=16)
}#End loop nux
rm(list = ls())
pkg_path <- "c:/git/interacting/r"
scripts<-list.files(pkg_path,full.names = TRUE)
for (scriptk in scripts) {
if (!basename(scriptk) %in% c('interprobe.R','interprobe_dev.R')) {
message("next:",basename(scriptk))
source(scriptk)
} }
data=NULL
model=NULL
k=NULL
zs=NULL
spotlights=NULL
draw=TRUE
histogram=TRUE
nbins=NULL
shade.up.to = 50  #below this sample size we shade to show few observations
xlab='moderator'
cols=c('red4','blue4','green4')
ylab1='Dependent Variable'
ylab2='Marginal Effect'
main1="GAM Simple Slopes"
main2='GAM Floodlight'
force.discrete.freqs=FALSE
n.bin.continuous = 10
max.unique=11
draw.simple.slopes=TRUE
draw.floodlight=TRUE
#Continuous
x=rnorm(1000)
z=rnorm(1000)
m1=rnorm(1000,mean=10)
m2=rnorm(1000,mean=15)
y.raw=x*z+m1+m2
e=rnorm(1000,sd=sd(y.raw))
y=y.raw+e
#0 If x is specified and it is in a model/data version of interprobe() treat as string
if (!is.null(model) | !is.null(data)) {
x <- deparse(substitute(x))
z <- deparse(substitute(z))
if (!is.null(y)) y <- deparse(substitute(y))
}
#1 Validate input and determine what was provided, vector, model, or data.frame
v = validate.input.combinations(data , model, x, y ,z)
#NOTE: See ./validate.input.combinations.R
#outputs $input data, input xyz, input
#------------------------------------------------------------------------------
#2 Get a dataframe
if (v$input.data==FALSE & v$input.xyz==TRUE)  data = data.frame(x=x,z=z,y=y)
if (v$input.model==TRUE)                      data = model$model
#v is a list produced in #1 above
#2.1 Remove "GAM" from  figure headers for non-GAM models
if (v$input.model==TRUE) {
if (!inherits(model, "gam")) {
#Pre-print 'linear' if we know it is linear
linear.st=''
if (inherits(model, "lm")) linear.st='Linear '
#Substitute default headers
if (main1=="GAM Simple Slopes") main1=paste0(linear.st,"Simple Slopes")
if (main2=="GAM Floodlight")    main2=paste0(linear.st,"Floodlight")
}
}
#------------------
if (v$input.data==FALSE & v$input.xyz==TRUE)
{
#Put vectors into dataframe
data=data.frame(x, z, y)
#Rename variables to refer to variable names
x='x'
z='z'
y='y'
}
ux  = sort(unique(data$x))
uz  = sort(unique(data$z))
nux = length(ux)     #nux number of unique x values
nuz = length(uz)     #nuz number of unique z values
#4.2 Check if only 1 value
if (nux==1) stop("interprobe says: there is only one observed value for the variable 'x'")
if (nuz==1) stop("interprobe says: there is only one observed value for the variable 'z'")
#4.3 Categorize as 'continuous' or 'discrete' moderators
moderation = ifelse(nuz>max.unique, 'continuous', 'discrete')
focal       = ifelse(nux>max.unique, 'continuous', 'discrete')
#5 set moderator values for computing marginal effects
if (moderation=='discrete')   zs = uz
if (moderation=='continuous') zs = seq(min(data$z),max(data$z),length.out=100)
#set focal predictor values
if (focal=='discrete')   xs = ux
if (focal=='continuous') xs = seq(min(data$x),max(data$x),length.out=100)
if (v$input.model==FALSE) model = estimate.model(nux,data,k)
#1. v is a list produced in #1 above (see validate.input.combinations.R)
if (draw.simple.slopes==TRUE) {
#7.1 x has 2 or 3 possible values
if (nux %in% c(2,3))
{
simple.slopes = list()
j=1
for (xj in ux)
{
#Make prediction data
ndj = expand.grid(z=zs,x=xj)
#Save marginal effects results
options(warn=-1)
simple.slopes[[j]] = marginaleffects::predictions(model, newdata = ndj,by='z')
options(warn=-0)
#Note: suppress warnings because `marginaleffects` warns about k as a missing variable
j=j+1
} #End loop
}  #End nux in 2,3
#7.2 x has more 4+ values
if (nux>=4)
{
#Spotlights of z
if (is.null(spotlights)) spotlights=quantile(data$z,c(.15,.5,.85),type=3)
simple.slopes = list()
j=1
for (zj in spotlights)
{
#Make prediction data
ndj = expand.grid(z=zj,x=xs)
ndj = add.covariates.at.mean(ndj, data)
#Save marginal effects results
options(warn=-1)
simple.slopes[[j]] = marginaleffects::predictions(model, newdata = ndj)
options(warn=-0)
#Note: suppress warnings because `marginaleffects` warns about k as a missing variable when it is specified
j=j+1
} #End loop
} #End 7.2 if nux>=4
}#End 7 if simple slopes
#--------------------------------------------------------------------------------
#8 Compute floodlight / Johnson-Neyman
if (draw.floodlight==TRUE)
{
#8.1 x has 2 or 3 possible values
if (nux %in% c(2,3))
{
floodlight = list()
#Marginal effect for condition 2 - 1, or both 3-1 and 2-1, so we exclude from loop 1, and add to all
j=1
for (xj in ux[-1])
{
#Make prediction data
ndj = expand.grid(z=zs,x=c(as.character(ux[1]),xj))
#Save marginal effects results
options(warn=-1)
floodlight[[j]] = marginaleffects::predictions(model, newdata = ndj,by='z')
floodlight[[j]]$x=xj
options(warn=-0)
#Note: suppress warnings because `marginaleffects` warns about k as a missing variable
#SEE https://github.com/vincentarelbundock/marginaleffects/issues/1031
j=j+1
} #End loop
} #End if nux in c(2,3)
#8.2 x has more 4+ values
if (nux>=4)
{
#Spotlights of z
if (is.null(spotlights)) spotlights=quantile(data$z,c(.15,.5,.85),type=3)
floodlight = list()
j=1
zj=spotlights[1]
for (zj in spotlights)
{
#Make prediction data
ndj = expand.grid(z=zj,x=xs)
ndj = add.covariates.at.mean(ndj, data)
#Save marginal effects results
options(warn=-1)
floodlight[[j]] = marginaleffects::slopes(model, newdata = ndj, var='x')
floodlight[[j]]$z=zj
options(warn=-0)
#Note: suppress warnings because `marginaleffects` warns about k as a missing variable when it is specified
j=j+1
} #End loop
} #End if nux>=4
} #End if draw floodlight
if (nux>=4) on_x_axis='x'
if (nux<=3) on_x_axis='z'
if (on_x_axis=='z') n.segments = nux
if (on_x_axis=='x') n.segments = length(spotlights)
if (on_x_axis=='x') {
gr=list()
nbins=length(levels(bins))
for (j in 1:nbins) gr[[j]] = rep(1,nbins)
}
bins
nbins
n.bin.continuous
bins = cut(data$z,n.bin.continuous)  #n.bin.continuous defaults to 10 bins for continuous data
bins
n.bin.continuous
n.bin.continuous=5
bins = cut(data$z,n.bin.continuous)  #n.bin.continuous defaults to 10 bins for continuous data
nbins = length(levels(bins))
nbins
nbins = n.bin.continuous
fx   = table(data$x,bins)
fx
bins = cut(data$x ,n.bin.continuous)  #n.bin.continuous defaults to 10 bins for continuous data
bins
nbins = n.bin.continuous
zbins <- cut(df$z,
breaks = c(-Inf, quantile(df$z,c(1/3,2/3)), Inf),
labels = c("z1", "z2", "z3"),
include.lowest = TRUE)
zbins <- cut(data$z,
breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),
labels = c("z1", "z2", "z3"),
include.lowest = TRUE)
zbins
fx   = table(binz,zbins)
fx   = table(bins , zbins)
fx
colSums(fx)
bins = cut(data$x ,n.bin.continuous,include.lowest=TRUE,labels=paste('xbin_',1:(n.bin.continuous)))
bins
nbins = n.bin.continuous
bins = cut(data$x ,nbins,include.lowest=TRUE,labels=paste('xbin_',1:(nbins)))  #n.bin.continuous defaults to 10 bins for continuous data
bins
bins = cut(data$x ,nbins,include.lowest=TRUE,labels=paste0('xbin_',1:(nbins)))  #n.bin.continuous defaults to 10 bins for continuous data
zbins <- cut(data$z,
breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),
labels = c("z1", "z2", "z3"),
include.lowest = TRUE)
fx   = table(bins , zbins)
fx
zbins <- cut(data$z,
breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),
labels = paste0("zbin_",1:3),
include.lowest = TRUE)
fx   = table(bins , zbins)
fx
px = prop.table(fx,1)
px
fx   = table(zbins , bins)
fx
px = prop.table(fx,1)
px
compute.slopes.discrete=function(ux, zs, model)
{
simple.slopes = list()
j=1
for (xj in ux)
{
#Make prediction data
ndj = expand.grid(z=zs,x=xj)
#Save marginal effects results
options(warn=-1)
simple.slopes[[j]] = marginaleffects::predictions(model, newdata = ndj,by='z')
options(warn=-0)
#Note: suppress warnings because `marginaleffects` warns about k as a missing variable
j=j+1
} #End loop
return(simple.slopes)
}
compute.slopes.discrete(ux, zs, model)
ux
zs
model
n=200
x=rep(c(1,2,3),n)
z=rnorm(3*n)
y.raw=x*z
e=rnorm(length(y.raw),sd=sd(y.raw))
y=y.raw+e
compute.slopes.continuous=function(spotlights, data, xs)
{
if (is.null(spotlights)) spotlights=quantile(data$z,c(.15,.5,.85),type=3)
simple.slopes = list()
j=1
for (zj in spotlights)
{
#Make prediction data
ndj = expand.grid(z=zj,x=xs)
ndj = add.covariates.at.mean(ndj, data)
#Save marginal effects results
options(warn=-1)
simple.slopes[[j]] = marginaleffects::predictions(model, newdata = ndj)
options(warn=-0)
#Note: suppress warnings because `marginaleffects` warns about k as a missing variable when it is specified
j=j+1
} #End loop
} #End of function
data$x
compute.slopes.continuous(spotlights , data, xs)
compute.slopes.continuous=function(spotlights, data, xs)
{
if (is.null(spotlights)) spotlights=quantile(data$z,c(.15,.5,.85),type=3)
simple.slopes = list()
j=1
for (zj in spotlights)
{
#Make prediction data
ndj = expand.grid(z=zj,x=xs)
ndj = add.covariates.at.mean(ndj, data)
#Save marginal effects results
options(warn=-1)
simple.slopes[[j]] = marginaleffects::predictions(model, newdata = ndj)
options(warn=-0)
#Note: suppress warnings because `marginaleffects` warns about k as a missing variable when it is specified
j=j+1
} #End loop
return(simple.slopes)
} #End of function
s=compute.slopes.continuous(spotlights , data, xs)
s
compute.floodlight.discrete=function(ux, zs, model)
{
floodlight = list()
#Marginal effect for condition 2 - 1, or both 3-1 and 2-1, so we exclude from loop 1, and add to all
j=1
for (xj in ux[-1])
{
#Make prediction data
ndj = expand.grid(z=zs,x=c(as.character(ux[1]),xj))
#Save marginal effects results
options(warn=-1)
floodlight[[j]] = marginaleffects::predictions(model, newdata = ndj,by='z')
floodlight[[j]]$x=xj
options(warn=-0)
#Note: suppress warnings because `marginaleffects` warns about k as a missing variable
#SEE https://github.com/vincentarelbundock/marginaleffects/issues/1031
j=j+1
} #End loop
return(floodlight)
}
nxbins = n.bin.continuous
nxbins
xbins  = cut(data$x ,nbins,include.lowest=TRUE,labels=paste0('xbin_',1:(nbins)))
zbins  = cut(data$z, breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(zbins , bins)
fx
diff(spotlights)
spotlights
names(spotlights)
diff(names(spotlights))
diff(as.numeric(names(spotlights)))
spotlights
mean(z<spotlights)
mean(z<spotlights[1])
mean(z<spotlights[2])
cut1 =( spotlights[1]+spotlights[2])/2)
cut1 =( spotlights[1]+spotlights[2])/2
cut1
cuts=c()
cuts[1] =( spotlights[1]+spotlights[2])/2
cuts[2] =( spotlights[3]+spotlights[2])/2
cuts
quantile(data$z,c(1/3,2/3))
nxbins = n.bin.continuous
#Cut x into nbins
xbins  = cut(data$x ,nxbins,include.lowest=TRUE,labels=paste0('xbin_',1:(nxbins)))
xbins
cuts=c()
cuts[1] =( spotlights[1]+spotlights[2])/2
cuts[2] =( spotlights[3]+spotlights[2])/2
zbins  = cut(data$z, breaks = c(-Inf, cuts, Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(zbins , bins)
fx
make.fbin = function(data  , n.bin.continuous,  moderation  )
{
#------------------------------------------------------------
#CASE 1  x: contintuous, always plot three lines for spotlights of z
if (nux>3) {
#How many bins for x values?
nxbins = n.bin.continuous
#Cut x into nbins
xbins  = cut(data$x ,nxbins,include.lowest=TRUE,labels=paste0('xbin_',1:(nxbins)))
#Cut z into three
cuts=c()
cuts[1] =( spotlights[1]+spotlights[2])/2
cuts[2] =( spotlights[3]+spotlights[2])/2
#Spotlights has to have three values, and it takes the midpoints of those three values to make the three bins
zbins  = cut(data$z, breaks = c(-Inf, cuts, Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
#Compute the cross frequencies
fx   = table(zbins , bins)
return(fx)
}
#------------------------------------------------------------
#CASE 2  x: discrete z: cont
if (nux<3 & moderation=='continuous') {
zbins  = cut(data$z, breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(zbins , ux)
return(fx)
}
#------------------------------------------------------------
#CASE 3  x: discrete z: discrete
if (nux<3 & moderation=='discrete') {
fx   = table(uz , ux)
return(fx)
}
}
x=rnorm(1000)
z=rnorm(1000)
spotlights=quantile(z,c(.15,.5,.85))
xbins  = cut(data$x ,nxbins,include.lowest=TRUE,labels=paste0('xbin_',1:(nxbins)))
xbins
cuts=c()
cuts[1] =( spotlights[1]+spotlights[2])/2
cuts[2] =( spotlights[3]+spotlights[2])/2
zbins  = cut(data$z, breaks = c(-Inf, cuts, Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(zbins , bins)
fx
xbins
nxbins
x=sample(c(0,1),1000)
x=sample(c(0,1),1000,replace = T)
z=rnorm(1000)
zbins  = cut(data$z, breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(zbins , ux)
fx
zbins
ux
ux=unique(x)
fx   = table(zbins , ux)
fx
ux
zbins
table(zbins , ux)
table(zbins , x)
x=sample(c(0,1),1000,replace = T)
z=sample(c(1,2,3,4,5,6,7),replace=T)
fx   = table(z , x)
z=sample(c(1,2,3,4,5,6,7),1000,replace=T)
table(z , x)
table(zbins , x)
make.fxz = function(data  , n.bin.continuous,  moderation  )
{
#------------------------------------------------------------
#CASE 1  x: contintuous, always plot three lines for spotlights of z
if (nux>3) {
#How many bins for x values?
nxbins = n.bin.continuous
#Cut x into nbins
xbins  = cut(data$x ,nxbins,include.lowest=TRUE,labels=paste0('xbin_',1:(nxbins)))
#Cut z into three
cuts=c()
cuts[1] =( spotlights[1]+spotlights[2])/2
cuts[2] =( spotlights[3]+spotlights[2])/2
#Spotlights has to have three values, and it takes the midpoints of those three values to make the three bins
zbins  = cut(data$z, breaks = c(-Inf, cuts, Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
#Compute the cross frequencies
fx   = table(xbins,zbins)
return(fx)
}
#------------------------------------------------------------
#CASE 2  x: discrete z: cont
if (nux<3 & moderation=='continuous') {
zbins  = cut(data$z, breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(x,zbins)
return(fx)
}
#------------------------------------------------------------
#CASE 3  x: discrete z: discrete
if (nux<3 & moderation=='discrete') {
fx   = table(x,z)
return(fx)
}
}
make.fxz = function(data  , n.bin.continuous,  moderation  )
{
#------------------------------------------------------------
#CASE 1  x: contintuous, always plot three lines for spotlights of z
if (nux>3) {
#How many bins for x values?
nxbins = n.bin.continuous
#Cut x into nbins
xbins  = cut(data$x ,nxbins,include.lowest=TRUE,labels=paste0('xbin_',1:(nxbins)))
#Cut z into three
cuts=c()
cuts[1] =( spotlights[1]+spotlights[2])/2
cuts[2] =( spotlights[3]+spotlights[2])/2
#Spotlights has to have three values, and it takes the midpoints of those three values to make the three bins
zbins  = cut(data$z, breaks = c(-Inf, cuts, Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
#Compute the cross frequencies
fx   = table(xbins,zbins)
return(fx)
}
#------------------------------------------------------------
#CASE 2  x: discrete z: cont
if (nux<3 & moderation=='continuous') {
zbins  = cut(data$z, breaks = c(-Inf, quantile(data$z,c(1/3,2/3)), Inf),  labels = paste0("zbin_",1:3), include.lowest = TRUE)
fx   = table(x,zbins)
return(fx)
}
#------------------------------------------------------------
#CASE 3  x: discrete z: discrete
if (nux<3 & moderation=='discrete') {
fx   = table(x,z)
return(fx)
}
}
