library('interacting')
library('interacting')
library('groundhog')
pkgs=c('mgcv','devtools')
date='2024-02-01'
groundhog.library(pkgs,date)
library('groundhog')
pkgs=c('mgcv','devtools')
date='2024-02-01'
groundhog.library(pkgs,date)
pkg_path <- "c:/git/interacting/r"
devtools::build(pkg_path,path=this.dir())
pkgs=c('mgcv','devtools','this.path')
date='2024-02-01'
groundhog.library(pkgs,date)
#devtools::build(pkg_path,path=this.dir())
devtools::build(pkg_path,path=this.dir())
devtools::install(pkg_path, dependencies = FALSE, build = TRUE)
library('interacting')
n=5005
x1=rnorm(n)
z1=rnorm(n)
y1.raw=x1*z1+pmin(z1,0)
e=rnorm(n,sd(y1.raw))
y1=y1.raw+e
interprobe(x,z,y)
interprobe(x1,z1,y1)
n=5005
x1=rnorm(n)
z1=rnorm(n)
y1.raw=x1*z1+pmin(z1,0)
e=rnorm(n,sd(y1.raw))
y1=y1.raw+e
interprobe(x1,z1,y1)
x1
data1=data.frame(x1,z1,y1)
interprobe(x1,z1,y1,data=data1)
lm1=lm(y1~x1*z1,data=data1)
interprobe(x=x1,z=z1,y=y1)
interprobe(model=lm1,x=x1,z=z1,data=data1)
lm1=lm(y1~x1*z1,data=data1)
devtools::install(pkg_path, dependencies = FALSE, build = TRUE)
library('interacting')
n=5005
x1=rnorm(n)
z1=rnorm(n)
y1.raw=x1*z1+pmin(z1,0)
e=rnorm(n,sd(y1.raw))
y1=y1.raw+e
data1=data.frame(x1,z1,y1)
interprobe(x1,z1,y1)
interprobe(x1,z1,y1,data=data1)
lm1=lm(y1~x1*z1,data=data1)
interprobe(model=lm1,x=x1,z=z1)
interprobe(model=lm1,x=x1,z=z1)
g1=gam(y1~x1*z1,data=data1)
g1=mgcv::gam(y1~x1*z1,data=data1)
interprobe(model=g1,x=x1,z=z1)
#SOURCE
rm(list = ls())
pkg_path <- "c:/git/interacting/r"
scripts<-list.files(pkg_path,full.names = TRUE)
for (scriptk in scripts) {
if (!basename(scriptk) %in% c('interprobe___.R','interprobe___.R','interprobe2.R')) {
message("next:",basename(scriptk))
source(scriptk)
} }
y=NULL
data=NULL
model=NULL
k=3
zs=NULL
spotlights=NULL
spotlight.labels=NULL
draw=TRUE
histogram=TRUE
nbins=NULL
n.max = 50  #below this sample size we shade to show few observations
xlab='moderator'
cols=c('red4','blue4','green4')
ylab1='Dependent Variable'
ylab2='Marginal Effect'
main1="GAM Simple Slopes"
main2='GAM Floodlight'
focal.label = 'Focal Predictor (x)'
xlim=NULL
force.discrete.freqs=FALSE
n.bin.continuous = 10
max.unique=11
draw.simple.slopes=TRUE
draw.floodlight=TRUE
legend.round=c(2,4)
file=NULL
x1=rnorm(n)
n=1000
x1=rnorm(n)
z1=rnorm(n,mean=10,sd=2)
y.raw = x1*z1
e=rnorm(n,sd=sd(y.raw))
y1=y.raw+e
lm1=lm(y1~x1*z1)
#  interprobe(x=x1 ,z=z1,y=y1)
interprobe(model=lm1,x=x1 ,z=z1)
library('groundhog')
pkgs=c('mgcv','devtools','this.path')
date='2024-02-01'
groundhog.library(pkgs,date)
pkg_path <- "c:/git/interacting/r"
#pkg_path <- "/Users/andres/Documents/[2] projects/[7] interacting/interacting/R" #in Andres's computer
#INSTALL
devtools::document(pkg_path)
#devtools::build(pkg_path,path=this.dir())
devtools::install(pkg_path, dependencies = FALSE, build = TRUE)
library('interacting')
n=1000
x1=rnorm(n)
z1=rnorm(n,mean=10,sd=2)
y.raw = x1*z1
e=rnorm(n,sd=sd(y.raw))
y1=y.raw+e
library('interacting')
n=1000
x1=rnorm(n)
z1=rnorm(n,mean=10,sd=2)
y.raw = x1*z1
e=rnorm(n,sd=sd(y.raw))
y1=y.raw+e
interprobe(x1,z1,y1)
#'Probe Interactions With GAM Simple Slopes and GAM Johnson-Neyman Curves
#'
#' Probe interaction as proposed in Simonsohn (2024), estimating a GAM model
#' and computing simple slopes ('spotlight') and Johnson-Neyman ('floodlight')
#' curves off the GAM model. While designed for GAM it can be used to probe
#' other models including lm()
#'
#'@param x the predictor of interest (in an experiment, the discrete randomly
#'assigned manipulation). Can be the name of a variable (e.g., x='treatment')
#'or data (e.g., x=c(1,3,1,4)
#'@param z the moderator. Can be the name of variable, or a vector with data
#'@param y the dependent variable. Can be the name of variable, or a vector with data
#'@param data an optional data frame with variables used in the model
#'@param model an optional model which will be probed (can be any model accepted
#'by package 'marginaleffects' including lm, glm, gam). If unspecified, a GAM model
#'is estimated on the provided data, including flexible main effects for x an z
#'and a flexible interaction.
#'@param k level of smoothness/flexibility used by mgcv::gam() to fit functions,
#'the default used by interprobe() is k=3, increasing it will lead to more wiggly
#' functions increasing risk of over-fitting. mgcv::gam() uses a much higher default
#' which interprobe opts-out of by specifying it to be k=3. In gam it is gam(y~s(x,k=3)).
#'@param spotlights vector with three values of the moderator at which simple slopes
#'and Johnsohn-Neyman curve are computed. Defaults to 15th, 50th and 85th percentile
#'of moderator values in the data.
#'@param spotlight.labels labels to use in the legend to indicate the spotlight values
#'@param histogram logical on whether sample sizes are depicted under the
#'@param max.unique integer with the cutoff at which interprobe() reports frequencies
#'for sets rather than individual values in the histogram
#'@param n.bin.continuous integer with number of bins to make for histogram
#'@param n.max integer with the frequency count at which color signaling
#'sample size maxes out and not longer gets darker with bigger samples.
#'@param xlab label for the x axis, defaults to be "Focal Predictor" when x is on the x-axis
#'and "Moderator" when z is in the x-axis. Users should replace default with a
#'clear descriptor of the variables (e.g., "z: age of participants")
#'@param cols colors used in the plot (defaults to blue, red, green)
#'@param ylab1 label for the y axis of the simple slopes plot (defaults to
#''Dependent Variable').
#'@param ylab2 label for the y axis of the Johnson-Neyman plot (defaults to
#''Marginal Effect').
#'@param main1 Header for simple slopes figure (defaults to 'GAM Simple Slopes')
#'@param main2 Header for Johnson Neyman figure (defaults to 'GAM Johnson-Neyman')
#'@param legend.round vector with minimum and maximum number of decimals to round
#'in the legend, e.g., c(0,0) forces 0 decimals
#'@param cols vector with three colors used in the plot (defaults to blue, red, green)
#'@param draw TRUE/FALSE for whether to make a plot
#'@param file character with path to file to save the figure to, can be .svg or
#'.png file (e.g., file='c:/temp/figure1.svg')
#'@param xlim numeric vector of length 2, giving the x coordinates range
#'
#'@export
interprobe <- function(
x=NULL,z=NULL,y=NULL,
model=NULL,
data=NULL,
k=3,
spotlights=NULL,
spotlight.labels=NULL,
histogram=TRUE,
max.unique = 11,
n.bin.continuous = 10,
n.max = 50,           #below this sample size we shade to show few observations
xlab='',
cols=c('red4','blue4','green4'),
ylab1='Dependent Variable',
ylab2='Marginal Effect',
main1="GAM Simple Slopes",
main2="GAM Johnson-Neyman",
legend.round=c(1,4),
draw=TRUE,
file=NULL,
xlim=NULL)
{
#0 If x is specified and it is in a model/data version of interprobe() treat as string
xvar <- clean_string(deparse(substitute(x)))
zvar <- clean_string(deparse(substitute(z)))
#Y if it exists
yvar=NULL
if (!is.null(y)) yvar <- clean_string(deparse(substitute(y)))
#1 Validate input and determine what was provided, vector, model, or data.frame
#First length and type of arguments
validate.arguments(x, z ,y ,  model,data, k,spotlights,spotlight.labels,histogram, max.unique,n.bin.continuous, n.max ,
xlab,ylab1,ylab2,main1,main2,cols,draw,legend.round,xlim,file,xvar,zvar,yvar)
#Then combination to determine if we were given a model or a dataset or vectors
v = validate.input.combinations(data , model, x, y ,z)
message('#100')
#2 Create data
#Extract if provided
if (v$input.data==FALSE & v$input.xyz==TRUE)  data = data.frame(x=x,z=z,y=y)
if (v$input.model==TRUE)                      data = model$model
#3 Number of unique x & z values
#3.1 Count
ux  = sort(unique(data[,xvar]))
uz  = sort(unique(data[,zvar]))
nux = length(ux)     #nux number of unique x values
nuz = length(uz)     #nuz number of unique z values
#3.2 Check if only 1 value
if (nux==1) exit("interprobe says: there is only one observed value for the focal (x) variable, '"    ,xvar,"'")
if (nuz==1) exit("interprobe says: there is only one observed value for the moderator (z) variable, '",zvar,"'")
#3.3 Categorize as 'continuous', 'discrete', 'categorical' focal predictor
if (nux>max.unique)          focal = "continuous"
if (nux<=max.unique & nux>3) focal = "discrete"
if (nux<=3)                  focal = "categorical"
#3.4 Moderator type
moderation = ifelse(nuz > max.unique, 'continuous', 'discrete')
#3.5
if (is.null(xlab)) {
xlab=ifelse(focal=='categorial','Moderator','Focal Predictor')
}
#4 set moderator values for computing marginal effects
if (moderation=='discrete')   zs = uz
if (moderation=='continuous') zs = seq(min(data[,zvar]),max(data[,zvar]),length.out=100)
#set focal predictor values
if (focal!='continuous')   xs = ux
if (focal=='continuous')   xs = seq(min(data[,xvar]),max(data[,xvar]),length.out=100)
#5 Estimate model (if the user did not provide it as an argument)
if (v$input.model==FALSE) model = estimate.model(nux,data,k,xvar,zvar,yvar)
#6 Set spotlight values and labels
if (is.null(spotlights)) {
spotlights=quantile(data[,zvar],c(.15,.5,.85),type=3)
if (is.null(spotlight.labels)) {
spotlight.labels=paste0(
c("15th percentile (","50th percentile (", "85th percentile (") ,
c(round2(as.numeric(spotlights), max.d=legend.round[2] , min.d=legend.round[1] )),
c(")",")",")"))
}
#Note: round2() is a function in utils.r that does rounding with default formatting
}
#If user set spotlights but not spotlight.labels, assign them
if (is.null(spotlight.labels)) spotlight.labels=as.numeric(spotlights)
#6 Compute simple slopes
if (nux <=3)  simple.slopes = compute.slopes.discrete  (ux, zs, model,xvar,zvar)
if (nux  >3)  simple.slopes = compute.slopes.continuous(spotlights, data, xs,model,xvar,zvar)
#7 Compute floodlight
if (nux <=3)  floodlight = compute.floodlight.discrete  (ux, zs, model,xvar,zvar)
if (nux  >3)  floodlight = compute.floodlight.continuous(spotlights, data, xs,model,xvar,zvar)
#8 Get fxz and gr
#fx:  Frequencies of each bin to determine line width and histogram
#gr:  How transparent to make the line that is being plotted, it's the n observartion in bin over n=100
#Frequencies
fxz.list = make.fxz(data  , n.bin.continuous,  moderation,nux , max.unique ,spotlights ,xvar,zvar)
fxz=fxz.list$fxz
#As % of the adequate sample size in n.max
gr = fxz
for (j in 1:ncol(fxz)) gr[,j] = pmin(fxz[,j]/n.max,1)
#9 Prepare output to be returned to enable plotting independently by user
#clean <- function(str) gsub("[^A-Za-z]", "", str)
df1 <- data.frame(do.call(rbind, simple.slopes))
df2 <- data.frame(do.call(rbind, floodlight))
df1 <- df1[, !names(df1) %in% c("rowid", "y","s.value","p.value","statistic")]
df2 <- df2[, !names(df2) %in% c("rowid", "y","s.value","p.value","statistic","term","predicted_lo",'predicted_hi','predicted')]
names(df1) = c('yhat','se.yhat','conf.low','conf.high',zvar,xvar)
names(df2) = c('dydx','se.dydx','conf.low','conf.high',zvar,xvar)
df1=df1[,c(6,5,1,2,3,4)]
df2=df2[,c(6,5,1,2,3,4)]
output=list(simple.slopes = df1, floodlight = df2, frequencies=fxz)
#10 Remove "GAM" from  figure headers for non-GAM models
if (v$input.model==TRUE) {
if (!inherits(model, "gam")) {
#Pre-print 'linear' if we know it is linear
linear.st=''
if (inherits(model, "lm")) linear.st='Linear '
#Substitute default headers
if (main1=="GAM Simple Slopes") main1=paste0(linear.st,"Simple Slopes")
if (main2=="GAM Floodlight")    main2=paste0(linear.st,"Floodlight")
}
}
#11 Plot for saving
if (!is.null(file)) {
#Get extension of file name
extension= tools::file_ext(file)
#Type of figure file
if (extension=='svg') svg(file,width=14,height=8)
if (extension=='png') png(file,width=14000,height=8000,res=1200)
#Two plots side by side
old_mfrow <- par('mfrow')
par(mfrow=c(1,2))
on.exit(par(mfrow=old_mfrow)) # Ensure original par settings are restored on function exit
#Plot simple slopes (spotlight)
make.plot (type='simple slopes', xlab, ylab1, main1, simple.slopes , histogram, data,xs, zs, gr,spotlights,cols,spotlight.labels,
focal,moderation,max.unique,fxz.list,nux,nuz,xlim,xvar,zvar)
#Plot Johson-Neyman (floodlight)
make.plot (type='floodlight', xlab, ylab2, main2, floodlight , histogram, data,xs, zs, gr,spotlights,cols,spotlight.labels,
focal,moderation,max.unique,fxz.list,nux,nuz,xlim,xvar,zvar)
#End
message("The figures have been saved to '",file,"'")
dev.off()
}
#12 Plot on screen
if (draw==TRUE)
{
#12.1 #Two plots side by side
old_mfrow <- par('mfrow')
par(mfrow=c(1,2))
on.exit(par(mfrow=old_mfrow)) # Ensure original par settings are restored on function exit
#12.2 Plot simple slopes
make.plot (type='simple slopes', xlab, ylab1, main1, simple.slopes , histogram, data,xs, zs, gr,spotlights,cols,spotlight.labels,
focal,moderation,max.unique,fxz.list,nux,nuz,xlim,xvar,zvar)
#12.3 Plot Floodlight/Johson-Neyman
make.plot (type='floodlight', xlab, ylab2, main2, floodlight , histogram, data,xs, zs, gr,spotlights,cols,spotlight.labels,
focal,moderation,max.unique,fxz.list,nux,nuz,xlim,xvar,zvar)
}
#13 return output for plotting on your own
invisible(output)
}
interprobe(x1,z1,y1)
devtools::install(pkg_path, dependencies = FALSE, build = TRUE)
library('interacting')
n=1000
x1=rnorm(n)
z1=rnorm(n,mean=10,sd=2)
y.raw = x1*z1
e=rnorm(n,sd=sd(y.raw))
y1=y.raw+e
#x,z,y
interprobe(x1,z1,y1)
devtools::install(pkg_path, dependencies = FALSE, build = TRUE)
library('groundhog')
pkgs=c('mgcv','devtools','this.path')
date='2024-02-01'
groundhog.library(pkgs,date)
pkg_path <- "c:/git/interacting/r"
devtools::install(pkg_path, dependencies = FALSE, build = TRUE)
library('interacting')
n=1000
x1=rnorm(n)
z1=rnorm(n,mean=10,sd=2)
y.raw = x1*z1
e=rnorm(n,sd=sd(y.raw))
y1=y.raw+e
#x,z,y
interprobe(x1,z1,y1)
devtools::install(pkg_path, dependencies = FALSE, build = TRUE)
library('interacting')
n=1000
x1=rnorm(n)
z1=rnorm(n,mean=10,sd=2)
y.raw = x1*z1
e=rnorm(n,sd=sd(y.raw))
y1=y.raw+e
#x,z,y
interprobe(x1,z1,y1)
devtools::install(pkg_path, dependencies = FALSE, build = TRUE)
library('interacting')
n=1000
x1=rnorm(n)
z1=rnorm(n,mean=10,sd=2)
y.raw = x1*z1
e=rnorm(n,sd=sd(y.raw))
y1=y.raw+e
#x,z,y
interprobe(x1,z1,y1)
devtools::install(pkg_path, dependencies = FALSE, build = TRUE)
library('interacting')
n=1000
x1=rnorm(n)
z1=rnorm(n,mean=10,sd=2)
y.raw = x1*z1
e=rnorm(n,sd=sd(y.raw))
y1=y.raw+e
#x,z,y
interprobe(x1,z1,y1)
devtools::install(pkg_path, dependencies = FALSE, build = TRUE)
library('interacting')
n=1000
x1=rnorm(n)
z1=rnorm(n,mean=10,sd=2)
y.raw = x1*z1
e=rnorm(n,sd=sd(y.raw))
y1=y.raw+e
#x,z,y
interprobe(x1,z1,y1)
#
devtools::install(pkg_path, dependencies = FALSE, build = TRUE)
library('interacting')
n=1000
x1=rnorm(n)
z1=rnorm(n,mean=10,sd=2)
y.raw = x1*z1
e=rnorm(n,sd=sd(y.raw))
y1=y.raw+e
#x,z,y
interprobe(x1,z1,y1)
devtools::install(pkg_path, dependencies = FALSE, build = TRUE)
library('interacting')
n=1000
x1=rnorm(n)
z1=rnorm(n,mean=10,sd=2)
y.raw = x1*z1
e=rnorm(n,sd=sd(y.raw))
y1=y.raw+e
#x,z,y
interprobe(x1,z1,y1)
devtools::install(pkg_path, dependencies = FALSE, build = TRUE)
library('interacting')
n=1000
x1=rnorm(n)
z1=rnorm(n,mean=10,sd=2)
y.raw = x1*z1
e=rnorm(n,sd=sd(y.raw))
y1=y.raw+e
#x,z,y
interprobe(x1,z1,y1)
interprobe(x1,z1,y1,data=data1)
data1=data.frame(x1,y1,z1)
interprobe(x1,z1,y1,data=data1)
devtools::install(pkg_path, dependencies = FALSE, build = TRUE)
library('interacting')
n=1000
x1=rnorm(n)
z1=rnorm(n,mean=10,sd=2)
y.raw = x1*z1
e=rnorm(n,sd=sd(y.raw))
y1=y.raw+e
data1=data.frame(x1,y1,z1)
#x,z,y
interprobe(x1,z1,y1)
interprobe(x1,z1,y1,data=data1)
interprobe(x1,z1,y1,data=data1)
lm1=lm(y1~x1*z1,data=data1)
interprobe(model=lm1,x=x1,z=z1)
g1=mgcv::gam(y1~x1*z1,data=data1)
interprobe(model=g1,x=x1,z=z1)
interprobe(model=g1,x='x1',z='z1')
pkg_path <- "c:/git/interacting/r"
#pkg_path <- "/Users/andres/Documents/[2] projects/[7] interacting/interacting/R" #in Andres's computer
#INSTALL
#devtools::document(pkg_path)
#devtools::build(pkg_path,path=this.dir())
devtools::install(pkg_path, dependencies = FALSE, build = TRUE)
library('interacting')
n=1000
x1=rnorm(n)
z1=rnorm(n,mean=10,sd=2)
y.raw = x1*z1
e=rnorm(n,sd=sd(y.raw))
y1=y.raw+e
data1=data.frame(x1,y1,z1)
g1=mgcv::gam(y1~x1*z1,data=data1)
interprobe(model=g1,x='x1',z='z1')
t1=interprobe(model=g1,x='x1',z='z1')
print(t1)
fig1=file.path(this.dir(),"Example 3.svg")
fig1=file.path(this.dir(),"Example 3.svg"))
this.dir()
library('groundhog')
pkgs=c('mgcv','devtools','this.path')
date='2024-02-01'
groundhog.library(pkgs,date)
fig1=file.path(this.dir(),"Example 3.svg"))
fig1=file.path(this.dir(),"Example 3.svg")
t1=interprobe(model=g1,x='x1',z='z1',file=fig1)
library('groundhog')
pkgs=c('mgcv','devtools','this.path')
date='2024-02-01'
groundhog.library(pkgs,date)
pkg_path <- "c:/git/interacting/r"
#pkg_path <- "/Users/andres/Documents/[2] projects/[7] interacting/interacting/R" #in Andres's computer
#devtools::document(pkg_path)
#devtools::build(pkg_path,path=this.dir())
devtools::install(pkg_path, dependencies = FALSE, build = TRUE)
library('interacting')
n=1000
x1=rnorm(n)
z1=rnorm(n,mean=10,sd=2)
y.raw = x1*z1
e=rnorm(n,sd=sd(y.raw))
y1=y.raw+e
data1=data.frame(x1,y1,z1)
interprobe(x1,z1,y1)
interprobe(x1,z1,y1,data=data1)
lm1=lm(y1~x1*z1,data=data1)
interprobe(model=lm1,x=x1,z=z1)
n=1200
x1=sample(c(1,2,3),n/3)
x1=sample(c(1,2,3),n/3)
n=1200
x1=sample(c(1,2,3),n/3,replace=TRUE)
z1=rnorm(n,mean=10,sd=2)
y.raw = x1*z1
e=rnorm(n,sd=sd(y.raw))
y1=y.raw+e
data1=data.frame(x1,y1,z1)
interprobe(model=g1,x='x1',z='z1')
interprobe(x='x1',z='z1',y='y1')
